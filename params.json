{"name":"Phalcon REST Base","tagline":"Best Practices for APIs Using the Phalcon Framework","body":"PhalconRest\r\n===========\r\n\r\nA base project for APIs using the [Phalcon][phalcon] framework\r\n---------------------------------------------------\r\n\r\nThe Phalcon framework is an awesome PHP framework that exists as a C-extension to the language.\r\nThis allows it to be incredibly fast.  But aside from its quickness, it is an amazingly\r\npowerful fraemwork with excellent [documentation][phalconDocs] that follows many best practises of\r\nmodern software development.  This includes using the Direct Injection pattern to handle service\r\nresolution across classes, a PSR-0 compliant autoloader, MVC architecture (or not), caching\r\nhandlers for database, flatfile, redis, etc.. and a ton of additional features.\r\n\r\nThe purpose of this project is to establish a base project with Phalcon that uses the best practices\r\nfrom the Phalcon Framework to implement best practises of [API Design][apigeeBook].\r\n\r\nWriting routes that respond with JSON is easy in any of the major frameworks.  What I've done here is to \r\ngo beyond that and extend the framework such that APIs written using this project are pragmatically \r\nREST-ish and have conveniance methods and patterns implemented that are more than a simple\r\n'echo json_encode($array)'.\r\n\r\nProvided are robust Error messages, controllers that parse searching strings and partial responsese, \r\nresponse classes for sending multiple MIME types based on the request, and examples of how to implement\r\nauthentication in a few ways, as well as a few tempaltes for implementing common REST-ish tasks.\r\n\r\nIt is highly recommended to read through the index.php, HTTPException.php and RESTController.php files, as\r\nI've tried to comment them extensively.\r\n\r\n\r\nAPI Assumptions\r\n---------------\r\n\r\n**URL Structure**\r\n\r\n```\r\n/v1/path1/path2?q=(search1:value1,search2:value2)&fields=(field1,field2,field3)&limit=10&offest=20&type=csv&suppress_error_codes=true\r\n```\r\n\r\n**Request Bodies**\r\n\r\nRequest bodies will be submitted as valid JSON.\r\n\r\nThe Fields\r\n-----------\r\n\r\n**Search**\r\n\r\nSearches are determined by the 'q' parameter.  Following that is a parenthesis enclosed list of key:value pairs, separated by commas.\r\n\r\n> ex: q=(name:Jonhson,city:Oklahoma)\r\n\r\n**Partial Responses**\r\n\r\nPartial responses are used to only return certain explicit fields from a record. They are determined by the 'fields' paramter, which is a list of field names separated by commas, enclosed in parenthesis.\r\n\r\n> ex: fields=(id,name,location)\r\n\r\n**Limit and Offset**\r\n\r\nOften used to paginate large result sets.  Offset is the record to start from, and limit is the number of records to return.\r\n\r\n> ex: limit=20&offset=20   will return results 21 to 40\r\n\r\n**Return Type**\r\n\r\nOverrides any accept headers.  JSON is assumed otherwise.  Return type handler must be implemented.\r\n\r\n> ex: type=xml\r\n\r\n**Suppressed Error Codes**\r\n\r\nSome clients require all responses to be a 200 (Flash, for example), even if there was an application error.\r\nWith this paramter included, the application will always return a 200 response code, and clients will be\r\nresponsible for checking the response body to ensure a valid response.\r\n\r\n> ex: suppress_error_codes=true\r\n\r\nResponses\r\n---------\r\n\r\nAll route controllers must return an array.  This array is used to create the response object.\r\n\r\n**JSON**\r\n\r\nJSON is the default response type.  It comes with an envelope wrapper, so responses will look like this:\r\n\r\n```\r\nGET /v1/example?q=(popular:true)&offset=1&limit=2&fields=(name,location,prince)\r\n\r\n{\r\n    \"_meta\": {\r\n        \"count\": 2,\r\n        \"status\": \"SUCCESS\"\r\n    },\r\n    \"records\": [\r\n        {\r\n            \"location\": \"Pride Rock\",\r\n            \"name\": \"Nala\",\r\n            \"prince\": \"Simba\"\r\n        },\r\n        {\r\n            \"location\": \"Castle\",\r\n            \"name\": \"Sleeping Beauty\",\r\n            \"prince\": \"Charming\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nThe envelope can be suppressed for responses via the 'envelope=false' query paramter.  This will return just the record set by itself as the body, and the meta information via X- headers.\r\n\r\nOften times, database field names are snake_cased.  However, when working with an API, developers \r\ngenreally prefer JSON fields to be returned in camelCase (many API requests are from browsers, in JS).\r\nThis project will by default convert all keys in a records response from snake_case to camelCase.\r\n\r\nThis can be turned off for your API by setting the JSONResponse's function \"convertSnakeCase(false)\".\r\n\r\n**CSV**\r\n\r\nCSV is the other implemented handler.  It uses the first record's keys as the header row, and then creates a csv from each row in the array.  The header row can be toggled off for responses.\r\n\r\n```\r\nname,location,princeName\r\nNala,\"Pride Rock\",Simba\r\n\"Sleeping Beauty\",Castle,Charming\r\n```\r\n\r\nErrors\r\n-------\r\n\r\nPhalconRest\\Exception\\HTTPException extends PHP's native exceptions.  Throwing this type of exception \r\nreturns a nicely formatted JSON response to the client.\r\n\r\n```\r\nthrow new \\PhalconRest\\Exceptions\\HTTPException(\r\n\t'Could not return results in specified format',\r\n\t403,\r\n\tarray(\r\n\t\t'dev' => 'Could not understand type specified by type paramter in query string.',\r\n\t\t'internalCode' => 'NF1000',\r\n\t\t'more' => 'Type may not be implemented. Choose either \"csv\" or \"json\"'\t\r\n\t)\r\n);\r\n```\r\n\r\nReturns this:\r\n\r\n```\r\n{\r\n    \"_meta\": {\r\n        \"status\": \"ERROR\"\r\n    },\r\n    \"error\": {\r\n        \"devMessage\": \"Could not understand type specified by type paramter in query string.\",\r\n        \"error\": 403,\r\n        \"errorCode\": \"NF1000\",\r\n        \"more\": \"Type may not be implemented. Choose either \\\"csv\\\" or \\\"json\\\"\",\r\n        \"userMessage\": \"Could not return results in specified format\"\r\n    }\r\n}\r\n```\r\n\r\n\r\nExample Controller\r\n-------------------\r\n\r\nThe Example Controller sets up a route at /example and implements all of the above query parameters.\r\nYou can mix and match any of these queries:\r\n\r\n>  api.example.local/v1/example?q=(name:Belle)\r\n\r\n>  api.example.local/v1/example?fields=(name,location)\r\n\r\n>  api.example.local/v1/example/5?fields=(name)&envelope=false\r\n\r\n>  api.example.local/v1/example?type=csv\r\n\r\n>  api.example.local/v1/example?q=(popular:true)&offset=1&limit=2&type=csv&fields=(name,location)\r\n\r\n[phalcon]: http://phalconphp.com/index\r\n[phalconDocs]: http://docs.phalconphp.com/en/latest/\r\n[apigeeBook]: https://blog.apigee.com/detail/announcement_new_ebook_on_web_api_design","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}